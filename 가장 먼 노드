문제 설명
n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다.

노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로 주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요.

제한사항
노드의 개수 n은 2 이상 20,000 이하입니다.
간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.
vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.
입출력 예
n	vertex	return
6	[[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]	3
입출력 예 설명
예제의 그래프를 표현하면 아래 그림과 같고, 1번 노드에서 가장 멀리 떨어진 노드는 4,5,6번 노드입니다.

import java.util.*;
class Solution {
    // 최댓값을 보관하는 변수
    int s_max = 0;
    class Node{
        // node의 번호
        int id;
        // 연결되는 node를 보관할 수 있는 ArrayList
        List<Node> inodes =  new ArrayList<Node>();
        // 연결된 vertex값을 보관하는 변수
        int count = 0;
        // Node값 초기화
        Node(int id){
            this.id = id;
        }
        //Node간의 연결관계를 추가하는 내부함수
        void addLink(Node a){
            this.inodes.add(a);
        }
        

    }
    // 지나갔다는 것을 표시해주는 함수
    public void f_visit(boolean[] check, Node node, Queue<Node> q, int count){
        // 지나갔다는 의미의 check
        check[node.id] = true;
        // vertex값의 초기화 또는 추가
        node.count = count;
        // queue에 Node 추가
        q.add(node);
    }
    public int solution(int n, int[][] edge) {
        //모든 Node를 담을 ArrayList
        List<Node> nodes = new ArrayList<Node>();
        int answer = 0;
        //모든 Node값의 초기화
        for(int i = 1 ; i <= n ; i++){
            nodes.add(new Node(i));
        }
        //node간의 연결관계를 ArrayList에 저장
        for(int i = 0; i <edge.length; i++){
            nodes.get(edge[i][0] - 1).addLink(nodes.get(edge[i][1] - 1));
            nodes.get(edge[i][1] - 1).addLink(nodes.get(edge[i][0] - 1));
        }
        //Node값을 입력하는 Queue
        Queue<Node> q = new LinkedList<Node>();
        //지나갔다는 걸 표시하려는 boolean
        boolean[] check = new boolean[n + 1];
        //boolean 값 초기화
        Arrays.fill(check, false);
        //1번 Node 값 지나갔음을 표시
        f_visit(check, nodes.get(0), q, 0);
        //Node의 연결관계가 없을 때까지 wihle문 실행
        while(!q.isEmpty()){
            //q에 있는 Node값을 임시 Node로 이동
            Node temp = q.poll();
            //temp Node에 연결되어있는 Node들 탐색
            for(int i = 0 ; i < temp.inodes.size(); i++){
                // 지나가지 않았을 경우 count값 1추가하고 지나가는 것을 표시해주는 함수 실행
                if(check[temp.inodes.get(i).id] == false){
                    f_visit(check, temp.inodes.get(i), q, temp.count + 1);
                }         
            }
            // 전체의 최댓값이 현재의 count 값보다 작을 경우에 최댓값 초기화
            if(temp.count > s_max){
                s_max = temp.count;
            }
        }
        // 최댓값을 가지고 있는 node의 갯수 추출
        for(int i = 0; i < n ; i++){
            if(s_max == nodes.get(i).count){
                answer++;
            }
        }
        return answer;
    }
}
